<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>nltk.classify</title>
    <meta name="generator" content="pydoctor 21.2.2"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            <a href="https://github.com/tristanlatr/nltk" class="projecthome">Natural Language Toolkit</a> <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="package"><code><code><a href="nltk.html">nltk</a></code><wbr></wbr>.<code><a href="nltk.classify.html">classify</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        package documentation
      </div>

      <div class="extrasDocstring">
        <a href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/classify/__init__.py" class="sourceLink">(source)</a>
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Classes and interfaces for labeling tokens with category labels (or
"class labels").  Typically, labels are represented with strings
(such as <tt class="rst-docutils literal">'health'</tt> or <tt class="rst-docutils literal">'sports'</tt>).  Classifiers can be used to
perform a wide range of classification tasks.  For example,
classifiers can be used...</p>
<ul class="rst-simple">
<li>to classify documents by topic</li>
<li>to classify ambiguous words by which word sense is intended</li>
<li>to classify acoustic signals by which phoneme they represent</li>
<li>to classify sentences by their author</li>
</ul>
<div class="rst-section" id="rst-features">
<h1 class="heading">Features</h1>
<p>In order to decide which category label is appropriate for a given
token, classifiers examine one or more 'features' of the token.  These
"features" are typically chosen by hand, and indicate which aspects
of the token are relevant to the classification decision.  For
example, a document classifier might use a separate feature for each
word, recording how often that word occurred in the document.</p>
</div>
<div class="rst-section" id="rst-featuresets">
<h1 class="heading">Featuresets</h1>
<p>The features describing a token are encoded using a "featureset",
which is a dictionary that maps from "feature names" to "feature
values".  Feature names are unique strings that indicate what aspect
of the token is encoded by the feature.  Examples include
<tt class="rst-docutils literal">'prevword'</tt>, for a feature whose value is the previous word; and
<tt class="rst-docutils literal"><span class="pre">'contains-word(library)'</span></tt> for a feature that is true when a document
contains the word <tt class="rst-docutils literal">'library'</tt>.  Feature values are typically
booleans, numbers, or strings, depending on which feature they
describe.</p>
<p>Featuresets are typically constructed using a "feature detector"
(also known as a "feature extractor").  A feature detector is a
function that takes a token (and sometimes information about its
context) as its input, and returns a featureset describing that token.
For example, the following feature detector converts a document
(stored as a list of words) to a featureset describing the set of
words included in the document:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># Define a feature detector function.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">document_features</span>(document):
<span class="py-more">... </span>    <span class="py-keyword">return</span> <span class="py-builtin">dict</span>([(<span class="py-string">'contains-word(%s)'</span> % w, <span class="py-builtin">True</span>) <span class="py-keyword">for</span> w <span class="py-keyword">in</span> document])</pre></blockquote>
<p>Feature detectors are typically applied to each token before it is fed
to the classifier:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-comment"># Classify each Gutenberg document.</span>
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">from</span> nltk.corpus <span class="py-keyword">import</span> gutenberg
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">for</span> fileid <span class="py-keyword">in</span> gutenberg.fileids(): <span class="py-comment"># doctest: +SKIP</span>
<span class="py-more">... </span>    doc = gutenberg.words(fileid) <span class="py-comment"># doctest: +SKIP</span>
<span class="py-more">... </span>    <span class="py-builtin">print</span>(fileid, classifier.classify(document_features(doc))) <span class="py-comment"># doctest: +SKIP</span></pre></blockquote>
<p>The parameters that a feature detector expects will vary, depending on
the task and the needs of the feature detector.  For example, a
feature detector for word sense disambiguation (WSD) might take as its
input a sentence, and the index of a word that should be classified,
and return a featureset for that word.  The following feature detector
for WSD includes features describing the left and right contexts of
the target word:</p>
<blockquote>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span><span class="py-keyword">def</span> <span class="py-defname">wsd_features</span>(sentence, index):
<span class="py-more">... </span>    featureset = {}
<span class="py-more">... </span>    <span class="py-keyword">for</span> i <span class="py-keyword">in</span> <span class="py-builtin">range</span>(<span class="py-builtin">max</span>(0, index-3), index):
<span class="py-more">... </span>        featureset[<span class="py-string">'left-context(%s)'</span> % sentence[i]] = <span class="py-builtin">True</span>
<span class="py-more">... </span>    <span class="py-keyword">for</span> i <span class="py-keyword">in</span> <span class="py-builtin">range</span>(index, <span class="py-builtin">max</span>(index+3, <span class="py-builtin">len</span>(sentence))):
<span class="py-more">... </span>        featureset[<span class="py-string">'right-context(%s)'</span> % sentence[i]] = <span class="py-builtin">True</span>
<span class="py-more">... </span>    <span class="py-keyword">return</span> featureset</pre></blockquote>
</div>
<div class="rst-section" id="rst-training-classifiers">
<h1 class="heading">Training Classifiers</h1>
<p>Most classifiers are built by training them on a list of hand-labeled
examples, known as the "training set".  Training sets are represented
as lists of <tt class="rst-docutils literal">(featuredict, label)</tt> tuples.</p>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id134">
  
  
  <tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.api.html">api</a></code></td>
    <td><span>Interfaces for labeling tokens with category labels (or "class labels").</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.decisiontree.html">decisiontree</a></code></td>
    <td><span>A classifier model that decides which label to assign to a token on the basis of a tree structure, where branches correspond to conditions on feature values, and leaves correspond to label assignments.</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.maxent.html">maxent</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.megam.html">megam</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.naivebayes.html">naivebayes</a></code></td>
    <td><span>A classifier based on the Naive Bayes algorithm.  In order to find the probability for a label, this algorithm first uses the Bayes rule to express P(label|features) in terms of P(label) and P(features|label):</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.positivenaivebayes.html">positivenaivebayes</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.rte_classify.html">rte_classify</a></code></td>
    <td><span>Simple classifier for RTE corpus.</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.scikitlearn.html">scikitlearn</a></code></td>
    <td><span>scikit-learn (<a class="rst-reference external" href="http://scikit-learn.org" target="_top">http://scikit-learn.org</a>) is a machine learning library for Python. It supports many classification algorithms, including SVMs, Naive Bayes, logistic regression (MaxEnt) and decision trees.</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.senna.html">senna</a></code></td>
    <td><span>A general interface to the SENNA pipeline that supports any of the operations specified in SUPPORTED_OPERATIONS.</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.svm.html">svm</a></code></td>
    <td><span>nltk.classify.svm was deprecated. For classification based on support vector machines SVMs use nltk.classify.scikitlearn (or <a class="rst-reference external" href="http://scikit-learn.org" target="_top">scikit-learn</a> directly).</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.tadm.html">tadm</a></code></td>
    <td><span class="undocumented">No module docstring; 0/1 variable, 3/6 functions documented</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.textcat.html">textcat</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.util.html">util</a></code></td>
    <td><span>Utility functions and classes for classifiers.</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.classify.weka.html">weka</a></code></td>
    <td><span>Classifiers that make use of the external 'Weka' package.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for <a href="https://github.com/tristanlatr/nltk" class="projecthome">Natural Language Toolkit</a>,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    21.2.2 at 2021-06-22 02:56:13.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>