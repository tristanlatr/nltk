<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>nltk.parse.viterbi.ViterbiParser</title>
    <meta name="generator" content="pydoctor 21.2.2"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            <a href="https://github.com/tristanlatr/nltk" class="projecthome">Natural Language Toolkit</a> <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="nltk.html">nltk</a></code><wbr></wbr>.<code><a href="nltk.parse.html">parse</a></code><wbr></wbr>.<code><a href="nltk.parse.viterbi.html">viterbi</a></code><wbr></wbr>.<code><a href="nltk.parse.viterbi.ViterbiParser.html">ViterbiParser</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">ViterbiParser</span>(<a href="nltk.parse.api.ParserI.html" title="nltk.parse.api.ParserI">ParserI</a>): <a href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L19" class="sourceLink">(source)</a></code></p>
        <p><a href="classIndex.html#nltk.parse.viterbi.ViterbiParser">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">A bottom-up ``PCFG`` parser that uses dynamic programming to find
the single most likely parse for a text.  The ``ViterbiParser`` parser
parses texts by filling in a "most likely constituent table".
This table records the most probable tree representation for any
given span and node value.  In particular, it has an entry for
every start index, end index, and node value, recording the most
likely subtree that spans from the start index to the end index,
and has the given node value.

The ``ViterbiParser`` parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar's start
symbol.

In order to find the most likely constituent with a given span and
node value, the ``ViterbiParser`` parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production's right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.

A pseudo-code description of the algorithm used by
``ViterbiParser`` is:

| Create an empty most likely constituent table, *MLC*.
| For width in 1...len(text):
|   For start in 1...len(text)-width:
|     For prod in grammar.productions:
|       For each sequence of subtrees [t[1], t[2], ..., t[n]] in MLC,
|         where t[i].label()==prod.rhs[i],
|         and the sequence covers [start:start+width]:
|           old_p = MLC[start, start+width, prod.lhs]
|           new_p = P(t[1])P(t[1])...P(t[n])P(prod)
|           if new_p &gt; old_p:
|             new_tree = Tree(prod.lhs, t[1], t[2], ..., t[n])
|             MLC[start, start+width, prod.lhs] = new_tree
| Return MLC[0, len(text), start_symbol]

:type _grammar: PCFG
:ivar _grammar: The grammar used to parse sentences.
:type _trace: int
:ivar _trace: The level of tracing output that should be generated
    when parsing a text.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id1127">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__init__">__init__</a></code></td>
    <td><span>Create a new ``ViterbiParser`` parser, that uses ``grammar`` to parse texts.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__repr__">__repr__</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#grammar">grammar</a></code></td>
    <td><span>:return: The grammar used by this parser.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#parse">parse</a></code></td>
    <td><span>:return: An iterator that generates parse trees for the sentence. When possible this list is sorted from most likely to least likely.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#trace">trace</a></code></td>
    <td><span>Set the level of tracing output that should be generated when parsing a text.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_add_constituents_spanning">_add_constituents_spanning</a></code></td>
    <td><span>Find any constituents that might cover ``span``, and add them to the most likely constituents table.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_find_instantiations">_find_instantiations</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_match_rhs">_match_rhs</a></code></td>
    <td><span>:return: a set of all the lists of children that cover ``span`` and that match ``rhs``. :rtype: list(list(ProbabilisticTree or token)</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_trace_lexical_insertion">_trace_lexical_insertion</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_trace_production">_trace_production</a></code></td>
    <td><span>Print trace output indicating that a given production has been applied at a given location.</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_grammar">_grammar</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_trace">_trace</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <code><a href="nltk.parse.api.ParserI.html">ParserI</a></code>:
          </p>
          <table class="children sortable" id="id1128">
  
  
  <tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="nltk.parse.api.ParserI.html#parse_all">parse_all</a></code></td>
    <td><span>:rtype: list(Tree)</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="nltk.parse.api.ParserI.html#parse_one">parse_one</a></code></td>
    <td><span>:rtype: Tree or None</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><code><a href="nltk.parse.api.ParserI.html#parse_sents">parse_sents</a></code></td>
    <td><span>Apply ``self.parse()`` to each element of ``sents``. :rtype: iter(iter(Tree))</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__init__</span>(self, grammar, trace=0):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L75">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Create a new ``ViterbiParser`` parser, that uses ``grammar`` to
parse texts.

:type grammar: PCFG
:param grammar: The grammar used to parse texts.
:type trace: int
:param trace: The level of tracing that should be used when
    parsing a text.  ``0`` will generate no tracing output;
    and higher numbers will produce more verbose tracing
    output.</p></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__repr__</span>(self):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L322">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.grammar">
    
  </a>
  <a name="grammar">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">grammar</span>(self):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L91">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="nltk.parse.api.ParserI.html#grammar">nltk.parse.api.ParserI.grammar</a></code></div>
    
    <div><p class="pre">:return: The grammar used by this parser.</p></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.parse">
    
  </a>
  <a name="parse">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">parse</span>(self, tokens):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L107">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <code><a href="nltk.parse.api.ParserI.html#parse">nltk.parse.api.ParserI.parse</a></code></div>
    
    <div><p class="pre">:return: An iterator that generates parse trees for the sentence.
When possible this list is sorted from most likely to least likely.

:param sent: The sentence to be parsed
:type sent: list(str)
:rtype: iter(Tree)</p></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser.trace">
    
  </a>
  <a name="trace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">trace</span>(self, trace=2):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L94">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Set the level of tracing output that should be generated when
parsing a text.

:type trace: int
:param trace: The trace level.  A trace level of ``0`` will
    generate no tracing output; and higher trace levels will
    produce more verbose tracing output.
:rtype: None</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._add_constituents_spanning">
    
  </a>
  <a name="_add_constituents_spanning">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_add_constituents_spanning</span>(self, span, constituents, tokens):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L150">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Find any constituents that might cover ``span``, and add them
to the most likely constituents table.

:rtype: None
:type span: tuple(int, int)
:param span: The section of the text for which we are
    trying to find possible constituents.  The span is
    specified as a pair of integers, where the first integer
    is the index of the first token that should be included in
    the constituent; and the second integer is the index of
    the first token that should not be included in the
    constituent.  I.e., the constituent should cover
    ``text[span[0]:span[1]]``, where ``text`` is the text
    that we are parsing.

:type constituents: dict(tuple(int,int,Nonterminal) -&gt; ProbabilisticToken or ProbabilisticTree)
:param constituents: The most likely constituents table.  This
    table records the most probable tree representation for
    any given span and node value.  In particular,
    ``constituents(s,e,nv)`` is the most likely
    ``ProbabilisticTree`` that covers ``text[s:e]``
    and has a node value ``nv.symbol()``, where ``text``
    is the text that we are parsing.  When
    ``_add_constituents_spanning`` is called, ``constituents``
    should contain all possible constituents that are shorter
    than ``span``.

:type tokens: list of tokens
:param tokens: The text we are parsing.  This is only used for
    trace output.</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._find_instantiations">
    
  </a>
  <a name="_find_instantiations">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_find_instantiations</span>(self, span, constituents):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L218">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">:return: a list of the production instantiations that cover a
    given span of the text.  A "production instantiation" is
    a tuple containing a production and a list of children,
    where the production's right hand side matches the list of
    children; and the children cover ``span``.  :rtype: list
    of ``pair`` of ``Production``, (list of
    (``ProbabilisticTree`` or token.

:type span: tuple(int, int)
:param span: The section of the text for which we are
    trying to find production instantiations.  The span is
    specified as a pair of integers, where the first integer
    is the index of the first token that should be covered by
    the production instantiation; and the second integer is
    the index of the first token that should not be covered by
    the production instantiation.
:type constituents: dict(tuple(int,int,Nonterminal) -&gt; ProbabilisticToken or ProbabilisticTree)
:param constituents: The most likely constituents table.  This
    table records the most probable tree representation for
    any given span and node value.  See the module
    documentation for more information.</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._match_rhs">
    
  </a>
  <a name="_match_rhs">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_match_rhs</span>(self, rhs, span, constituents):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L250">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">:return: a set of all the lists of children that cover ``span``
    and that match ``rhs``.
:rtype: list(list(ProbabilisticTree or token)

:type rhs: list(Nonterminal or any)
:param rhs: The list specifying what kinds of children need to
    cover ``span``.  Each nonterminal in ``rhs`` specifies
    that the corresponding child should be a tree whose node
    value is that nonterminal's symbol.  Each terminal in ``rhs``
    specifies that the corresponding child should be a token
    whose type is that terminal.
:type span: tuple(int, int)
:param span: The section of the text for which we are
    trying to find child lists.  The span is specified as a
    pair of integers, where the first integer is the index of
    the first token that should be covered by the child list;
    and the second integer is the index of the first token
    that should not be covered by the child list.
:type constituents: dict(tuple(int,int,Nonterminal) -&gt; ProbabilisticToken or ProbabilisticTree)
:param constituents: The most likely constituents table.  This
    table records the most probable tree representation for
    any given span and node value.  See the module
    documentation for more information.</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._trace_lexical_insertion">
    
  </a>
  <a name="_trace_lexical_insertion">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_trace_lexical_insertion</span>(self, token, index, width):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L317">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._trace_production">
    
  </a>
  <a name="_trace_production">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_trace_production</span>(self, production, p, span, width):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L294">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Print trace output indicating that a given production has been
applied at a given location.

:param production: The production that has been applied
:type production: Production
:param p: The probability of the tree produced by the production.
:type p: float
:param span: The span of the production
:type span: tuple
:rtype: None</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._grammar">
    
  </a>
  <a name="_grammar">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_grammar</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L88">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.parse.viterbi.ViterbiParser._trace">
    
  </a>
  <a name="_trace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_trace</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/f83d0acf07ed0fd627306ec5ae73265b05025e51/nltk/parse/viterbi.py#L89">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for <a href="https://github.com/tristanlatr/nltk" class="projecthome">Natural Language Toolkit</a>,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    21.2.2 at 2021-06-22 02:51:08.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>