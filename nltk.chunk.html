<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>nltk.chunk</title>
    <meta name="generator" content="pydoctor 21.2.2"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            <a href="https://github.com/tristanlatr/nltk" class="projecthome">Natural Language Toolkit</a> <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="package"><code><code><a href="nltk.html">nltk</a></code><wbr></wbr>.<code><a href="nltk.chunk.html">chunk</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        package documentation
      </div>

      <div class="extrasDocstring">
        <a href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/chunk/__init__.py" class="sourceLink">(source)</a>
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p>Classes and interfaces for identifying non-overlapping linguistic
groups (such as base noun phrases) in unrestricted text.  This task is
called "chunk parsing" or "chunking", and the identified groups are
called "chunks".  The chunked text is represented using a shallow
tree called a "chunk structure."  A chunk structure is a tree
containing tokens and chunks, where each chunk is a subtree containing
only tokens.  For example, the chunk structure for base noun phrase
chunks in the sentence "I saw the big dog on the hill" is:</p>
<pre class="rst-literal-block">
(SENTENCE:
  (NP: &lt;I&gt;)
  &lt;saw&gt;
  (NP: &lt;the&gt; &lt;big&gt; &lt;dog&gt;)
  &lt;on&gt;
  (NP: &lt;the&gt; &lt;hill&gt;))
</pre>
<p>To convert a chunk structure back to a list of tokens, simply use the
chunk structure's <tt class="rst-docutils literal">leaves()</tt> method.</p>
<p>This module defines <tt class="rst-docutils literal">ChunkParserI</tt>, a standard interface for
chunking texts; and <tt class="rst-docutils literal">RegexpChunkParser</tt>, a regular-expression based
implementation of that interface. It also defines <tt class="rst-docutils literal">ChunkScore</tt>, a
utility class for scoring chunk parsers.</p>
<div class="rst-section" id="rst-regexpchunkparser">
<h1 class="heading">RegexpChunkParser</h1>
<p><tt class="rst-docutils literal">RegexpChunkParser</tt> is an implementation of the chunk parser interface
that uses regular-expressions over tags to chunk a text.  Its
<tt class="rst-docutils literal">parse()</tt> method first constructs a <tt class="rst-docutils literal">ChunkString</tt>, which encodes a
particular chunking of the input text.  Initially, nothing is
chunked.  <tt class="rst-docutils literal">parse.RegexpChunkParser</tt> then applies a sequence of
<tt class="rst-docutils literal">RegexpChunkRule</tt> rules to the <tt class="rst-docutils literal">ChunkString</tt>, each of which modifies
the chunking that it encodes.  Finally, the <tt class="rst-docutils literal">ChunkString</tt> is
transformed back into a chunk structure, which is returned.</p>
<p><tt class="rst-docutils literal">RegexpChunkParser</tt> can only be used to chunk a single kind of phrase.
For example, you can use an <tt class="rst-docutils literal">RegexpChunkParser</tt> to chunk the noun
phrases in a text, or the verb phrases in a text; but you can not
use it to simultaneously chunk both noun phrases and verb phrases in
the same text.  (This is a limitation of <tt class="rst-docutils literal">RegexpChunkParser</tt>, not of
chunk parsers in general.)</p>
<div class="rst-section" id="rst-regexpchunkrules">
<h2 class="heading">RegexpChunkRules</h2>
<p>A <tt class="rst-docutils literal">RegexpChunkRule</tt> is a transformational rule that updates the
chunking of a text by modifying its <tt class="rst-docutils literal">ChunkString</tt>.  Each
<tt class="rst-docutils literal">RegexpChunkRule</tt> defines the <tt class="rst-docutils literal">apply()</tt> method, which modifies
the chunking encoded by a <tt class="rst-docutils literal">ChunkString</tt>.  The
<tt class="rst-docutils literal">RegexpChunkRule</tt> class itself can be used to implement any
transformational rule based on regular expressions.  There are
also a number of subclasses, which can be used to implement
simpler types of rules:</p>
<blockquote>
<ul class="rst-simple">
<li><tt class="rst-docutils literal">ChunkRule</tt> chunks anything that matches a given regular
expression.</li>
<li><tt class="rst-docutils literal">StripRule</tt> strips anything that matches a given regular
expression.</li>
<li><tt class="rst-docutils literal">UnChunkRule</tt> will un-chunk any chunk that matches a given
regular expression.</li>
<li><tt class="rst-docutils literal">MergeRule</tt> can be used to merge two contiguous chunks.</li>
<li><tt class="rst-docutils literal">SplitRule</tt> can be used to split a single chunk into two
smaller chunks.</li>
<li><tt class="rst-docutils literal">ExpandLeftRule</tt> will expand a chunk to incorporate new
unchunked material on the left.</li>
<li><tt class="rst-docutils literal">ExpandRightRule</tt> will expand a chunk to incorporate new
unchunked material on the right.</li>
</ul>
</blockquote>
<div class="rst-section" id="rst-tag-patterns">
<h3 class="heading">Tag Patterns</h3>
<p>A <tt class="rst-docutils literal">RegexpChunkRule</tt> uses a modified version of regular
expression patterns, called "tag patterns".  Tag patterns are
used to match sequences of tags.  Examples of tag patterns are:</p>
<pre class="rst-literal-block">
r'(&lt;DT&gt;|&lt;JJ&gt;|&lt;NN&gt;)+'
r'&lt;NN&gt;+'
r'&lt;NN.*&gt;'
</pre>
<p>The differences between regular expression patterns and tag
patterns are:</p>
<blockquote>
<ul class="rst-simple">
<li>In tag patterns, <tt class="rst-docutils literal">'&lt;'</tt> and <tt class="rst-docutils literal">'&gt;'</tt> act as parentheses; so
<tt class="rst-docutils literal"><span class="pre">'&lt;NN&gt;+'</span></tt> matches one or more repetitions of <tt class="rst-docutils literal">'&lt;NN&gt;'</tt>, not
<tt class="rst-docutils literal">'&lt;NN'</tt> followed by one or more repetitions of <tt class="rst-docutils literal">'&gt;'</tt>.</li>
<li>Whitespace in tag patterns is ignored.  So
<tt class="rst-docutils literal">'&lt;DT&gt; | &lt;NN&gt;'</tt> is equivalant to <tt class="rst-docutils literal"><span class="pre">'&lt;DT&gt;|&lt;NN&gt;'</span></tt></li>
<li>In tag patterns, <tt class="rst-docutils literal">'.'</tt> is equivalant to <tt class="rst-docutils literal"><span class="pre">'[^{}&lt;&gt;]'</span></tt>; so
<tt class="rst-docutils literal"><span class="pre">'&lt;NN.*&gt;'</span></tt> matches any single tag starting with <tt class="rst-docutils literal">'NN'</tt>.</li>
</ul>
</blockquote>
<p>The function <tt class="rst-docutils literal">tag_pattern2re_pattern</tt> can be used to transform
a tag pattern to an equivalent regular expression pattern.</p>
</div>
</div>
<div class="rst-section" id="rst-efficiency">
<h2 class="heading">Efficiency</h2>
<p>Preliminary tests indicate that <tt class="rst-docutils literal">RegexpChunkParser</tt> can chunk at a
rate of about 300 tokens/second, with a moderately complex rule set.</p>
<p>There may be problems if <tt class="rst-docutils literal">RegexpChunkParser</tt> is used with more than
5,000 tokens at a time.  In particular, evaluation of some regular
expressions may cause the Python regular expression engine to
exceed its maximum recursion depth.  We have attempted to minimize
these problems, but it is impossible to avoid them completely.  We
therefore recommend that you apply the chunk parser to a single
sentence at a time.</p>
</div>
<div class="rst-section" id="rst-emacs-tip">
<h2 class="heading">Emacs Tip</h2>
<p>If you evaluate the following elisp expression in emacs, it will
colorize a <tt class="rst-docutils literal">ChunkString</tt> when you use an interactive python shell
with emacs or xemacs ("C-c !"):</p>
<pre class="rst-literal-block">
(let ()
  (defconst comint-mode-font-lock-keywords
    '(("&lt;[^&gt;]+&gt;" 0 'font-lock-reference-face)
      ("[{}]" 0 'font-lock-function-name-face)))
  (add-hook 'comint-mode-hook (lambda () (turn-on-font-lock))))
</pre>
<p>You can evaluate this code by copying it to a temporary buffer,
placing the cursor after the last close parenthesis, and typing
"<tt class="rst-docutils literal"><span class="pre">C-x</span> <span class="pre">C-e</span></tt>".  You should evaluate it before running the interactive
session.  The change will last until you close emacs.</p>
</div>
<div class="rst-section" id="rst-unresolved-issues">
<h2 class="heading">Unresolved Issues</h2>
<p>If we use the <tt class="rst-docutils literal">re</tt> module for regular expressions, Python's
regular expression engine generates "maximum recursion depth
exceeded" errors when processing very large texts, even for
regular expressions that should not require any recursion.  We
therefore use the <tt class="rst-docutils literal">pre</tt> module instead.  But note that <tt class="rst-docutils literal">pre</tt>
does not include Unicode support, so this module will not work
with unicode strings.  Note also that <tt class="rst-docutils literal">pre</tt> regular expressions
are not quite as advanced as <tt class="rst-docutils literal">re</tt> ones (e.g., no leftward
zero-length assertions).</p>
</div>
</div>
</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id101">
  
  
  <tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.chunk.api.html">api</a></code></td>
    <td><span class="undocumented">No module docstring; 1/1 class documented</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.chunk.named_entity.html">named_entity</a></code></td>
    <td><span>Named entity chunker</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.chunk.regexp.html">regexp</a></code></td>
    <td><span class="undocumented">No module docstring; 0/1 variable, 3/3 functions, 12/12 classes documented</span></td>
  </tr><tr class="module">
    
    <td>Module</td>
    <td><code><a href="nltk.chunk.util.html">util</a></code></td>
    <td><span class="undocumented">No module docstring; 0/3 variable, 7/10 functions, 1/1 class documented</span></td>
  </tr>
</table>
        

          <p class="fromInitPy">From <code>__init__.py</code>:</p><table class="children sortable" id="id102">
  
  
  <tr class="function">
    
    <td>Function</td>
    <td><code><a href="#ne_chunk">ne_chunk</a></code></td>
    <td><span>Use NLTK's currently recommended named entity chunker to chunk the given list of tagged tokens.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#ne_chunk_sents">ne_chunk_sents</a></code></td>
    <td><span>Use NLTK's currently recommended named entity chunker to chunk the given list of tagged sentences, each consisting of a list of tagged tokens.</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><code><a href="#CHUNK_TAG_PATTERN">CHUNK_TAG_PATTERN</a></code></td>
    <td><span>A regular expression to test whether a tag
pattern is valid.</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_BINARY_NE_CHUNKER">_BINARY_NE_CHUNKER</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><code><a href="#_MULTICLASS_NE_CHUNKER">_MULTICLASS_NE_CHUNKER</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
      </div>

      <div id="childList">

        <div class="basevariable">
  
  
  <a name="nltk.chunk.CHUNK_TAG_PATTERN">
    
  </a>
  <a name="CHUNK_TAG_PATTERN">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">CHUNK_TAG_PATTERN</span>: regexp =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/chunk/__init__.py#L150">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>A regular expression to test whether a tag
pattern is valid.</div>
  </div>
</div><div class="basevariable private">
  
  
  <a name="nltk.chunk._BINARY_NE_CHUNKER">
    
  </a>
  <a name="_BINARY_NE_CHUNKER">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_BINARY_NE_CHUNKER</span>: <code><a href="https://docs.python.org/3/library/stdtypes.html#str">str</a></code> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/chunk/__init__.py#L172">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basevariable private">
  
  
  <a name="nltk.chunk._MULTICLASS_NE_CHUNKER">
    
  </a>
  <a name="_MULTICLASS_NE_CHUNKER">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_MULTICLASS_NE_CHUNKER</span>: <code><a href="https://docs.python.org/3/library/stdtypes.html#str">str</a></code> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/chunk/__init__.py#L173">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction">
  
  
  <a name="nltk.chunk.ne_chunk">
    
  </a>
  <a name="ne_chunk">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">ne_chunk</span>(tagged_tokens, binary=False):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/chunk/__init__.py#L176">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Use NLTK's currently recommended named entity chunker to
chunk the given list of tagged tokens.</div>
  </div>
</div><div class="basefunction">
  
  
  <a name="nltk.chunk.ne_chunk_sents">
    
  </a>
  <a name="ne_chunk_sents">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">ne_chunk_sents</span>(tagged_sentences, binary=False):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/chunk/__init__.py#L189">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Use NLTK's currently recommended named entity chunker to chunk the
given list of tagged sentences, each consisting of a list of tagged tokens.</div>
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for <a href="https://github.com/tristanlatr/nltk" class="projecthome">Natural Language Toolkit</a>,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    21.2.2 at 2021-06-22 02:56:13.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>