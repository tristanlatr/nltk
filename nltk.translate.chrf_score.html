<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>nltk.translate.chrf_score : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header navbar-brand">
          <a href="https://github.com/tristanlatr/nltk">Natural Language Toolkit</a>
          <a href="index.html">API Documentation</a>
        </div>
      </div>
    </nav>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><code><a href="nltk.html">nltk</a></code>.<code><a href="nltk.translate.html">translate</a></code>.<code><a href="nltk.translate.chrf_score.html">chrf_score</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        <a href="https://github.com/tristanlatr/nltk/tree/cab27f08bc0f78151e7dd16ec110d324f8c05a72/nltk/translate/chrf_score.py">(source)</a>
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">ChrF score implementation </p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id1866">
  
  <tr class="function">
    
    <td>Function</td>
    <td><code><a href="#sentence_chrf">sentence_chrf</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#chrf_precision_recall_fscore_support">chrf_precision_recall_fscore_support</a></code></td>
    <td><span>This function computes the precision, recall and fscore from the ngram overlaps. It returns the `support` which is the true positive score.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><code><a href="#corpus_chrf">corpus_chrf</a></code></td>
    <td><span>Calculates the corpus level CHRF (Character n-gram F-score), it is the macro-averaged value of the sentence/segment level CHRF score.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><code><a href="#_preprocess">_preprocess</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction">
  
  <a name="nltk.translate.chrf_score.sentence_chrf">
    
  </a>
  <a name="sentence_chrf">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">sentence_chrf</span>(reference, hypothesis, min_len=1, max_len=6, beta=3.0, ignore_whitespace=True):
    <a class="functionSourceLink" href="https://github.com/tristanlatr/nltk/tree/cab27f08bc0f78151e7dd16ec110d324f8c05a72/nltk/translate/chrf_score.py#L17">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Calculates the sentence level CHRF (Character n-gram F-score) described in
 - Maja Popovic. 2015. CHRF: Character n-gram F-score for Automatic MT Evaluation.
   In Proceedings of the 10th Workshop on Machine Translation.
   http://www.statmt.org/wmt15/pdf/WMT49.pdf
 - Maja Popovic. 2016. CHRF Deconstructed: Î² Parameters and n-gram Weights.
   In Proceedings of the 1st Conference on Machine Translation.
   http://www.statmt.org/wmt16/pdf/W16-2341.pdf

This implementation of CHRF only supports a single reference at the moment.

For details not reported in the paper, consult Maja Popovic's original
implementation: https://github.com/m-popovic/chrF

The code should output results equivalent to running CHRF++ with the
following options: -nw 0 -b 3

An example from the original BLEU paper
http://www.aclweb.org/anthology/P02-1040.pdf

    &gt;&gt;&gt; ref1 = str('It is a guide to action that ensures that the military '
    ...            'will forever heed Party commands').split()
    &gt;&gt;&gt; hyp1 = str('It is a guide to action which ensures that the military '
    ...            'always obeys the commands of the party').split()
    &gt;&gt;&gt; hyp2 = str('It is to insure the troops forever hearing the activity '
    ...            'guidebook that party direct').split()
    &gt;&gt;&gt; sentence_chrf(ref1, hyp1) # doctest: +ELLIPSIS
    0.6349...
    &gt;&gt;&gt; sentence_chrf(ref1, hyp2) # doctest: +ELLIPSIS
    0.3330...

The infamous "the the the ... " example

    &gt;&gt;&gt; ref = 'the cat is on the mat'.split()
    &gt;&gt;&gt; hyp = 'the the the the the the the'.split()
    &gt;&gt;&gt; sentence_chrf(ref, hyp)  # doctest: +ELLIPSIS
    0.1468...

An example to show that this function allows users to use strings instead of
tokens, i.e. list(str) as inputs.

    &gt;&gt;&gt; ref1 = str('It is a guide to action that ensures that the military '
    ...            'will forever heed Party commands')
    &gt;&gt;&gt; hyp1 = str('It is a guide to action which ensures that the military '
    ...            'always obeys the commands of the party')
    &gt;&gt;&gt; sentence_chrf(ref1, hyp1) # doctest: +ELLIPSIS
    0.6349...
    &gt;&gt;&gt; type(ref1) == type(hyp1) == str
    True
    &gt;&gt;&gt; sentence_chrf(ref1.split(), hyp1.split()) # doctest: +ELLIPSIS
    0.6349...

To skip the unigrams and only use 2- to 3-grams:

    &gt;&gt;&gt; sentence_chrf(ref1, hyp1, min_len=2, max_len=3) # doctest: +ELLIPSIS
    0.6617...

:param references: reference sentence
:type references: list(str) / str
:param hypothesis: a hypothesis sentence
:type hypothesis: list(str) / str
:param min_len: The minimum order of n-gram this function should extract.
:type min_len: int
:param max_len: The maximum order of n-gram this function should extract.
:type max_len: int
:param beta: the parameter to assign more importance to recall over precision
:type beta: float
:param ignore_whitespace: ignore whitespace characters in scoring
:type ignore_whitespace: bool
:return: the sentence level CHRF score.
:rtype: float</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="nltk.translate.chrf_score._preprocess">
    
  </a>
  <a name="_preprocess">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_preprocess</span>(sent, ignore_whitespace):
    <a class="functionSourceLink" href="https://github.com/tristanlatr/nltk/tree/cab27f08bc0f78151e7dd16ec110d324f8c05a72/nltk/translate/chrf_score.py#L102">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="nltk.translate.chrf_score.chrf_precision_recall_fscore_support">
    
  </a>
  <a name="chrf_precision_recall_fscore_support">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">chrf_precision_recall_fscore_support</span>(reference, hypothesis, n, beta=3.0, epsilon=1e-16):
    <a class="functionSourceLink" href="https://github.com/tristanlatr/nltk/tree/cab27f08bc0f78151e7dd16ec110d324f8c05a72/nltk/translate/chrf_score.py#L112">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">This function computes the precision, recall and fscore from the ngram
overlaps. It returns the `support` which is the true positive score.

By underspecifying the input type, the function will be agnostic as to how
it computes the ngrams and simply take the whichever element in the list;
it could be either token or character.

:param reference: The reference sentence.
:type reference: list
:param hypothesis: The hypothesis sentence.
:type hypothesis: list
:param n: Extract up to the n-th order ngrams
:type n: int
:param beta: The parameter to assign more importance to recall over precision.
:type beta: float
:param epsilon: The fallback value if the hypothesis or reference is empty.
:type epsilon: float
:return: Returns the precision, recall and f-score and support (true positive).
:rtype: tuple(float)</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="nltk.translate.chrf_score.corpus_chrf">
    
  </a>
  <a name="corpus_chrf">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">corpus_chrf</span>(references, hypotheses, min_len=1, max_len=6, beta=3.0, ignore_whitespace=True):
    <a class="functionSourceLink" href="https://github.com/tristanlatr/nltk/tree/cab27f08bc0f78151e7dd16ec110d324f8c05a72/nltk/translate/chrf_score.py#L155">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Calculates the corpus level CHRF (Character n-gram F-score), it is the
macro-averaged value of the sentence/segment level CHRF score.

This implementation of CHRF only supports a single reference at the moment.

    &gt;&gt;&gt; ref1 = str('It is a guide to action that ensures that the military '
    ...            'will forever heed Party commands').split()
    &gt;&gt;&gt; ref2 = str('It is the guiding principle which guarantees the military '
    ...            'forces always being under the command of the Party').split()
    &gt;&gt;&gt;
    &gt;&gt;&gt; hyp1 = str('It is a guide to action which ensures that the military '
    ...            'always obeys the commands of the party').split()
    &gt;&gt;&gt; hyp2 = str('It is to insure the troops forever hearing the activity '
    ...            'guidebook that party direct')
    &gt;&gt;&gt; corpus_chrf([ref1, ref2, ref1, ref2], [hyp1, hyp2, hyp2, hyp1]) # doctest: +ELLIPSIS
    0.3910...

:param references: a corpus of list of reference sentences, w.r.t. hypotheses
:type references: list(list(str))
:param hypotheses: a list of hypothesis sentences
:type hypotheses: list(list(str))
:param min_len: The minimum order of n-gram this function should extract.
:type min_len: int
:param max_len: The maximum order of n-gram this function should extract.
:type max_len: int
:param beta: the parameter to assign more importance to recall over precision
:type beta: float
:param ignore_whitespace: ignore whitespace characters in scoring
:type ignore_whitespace: bool
:return: the sentence level CHRF score.
:rtype: float</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for <a href="https://github.com/tristanlatr/nltk">Natural Language Toolkit</a>, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 21.2.2 at 2021-06-22 02:47:44.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>