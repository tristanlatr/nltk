<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  

  <head>
    
    <title>nltk.tag.brill_trainer.BrillTaggerTrainer</title>
    <meta name="generator" content="pydoctor 21.2.2"> 
        
    </meta>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=0.75" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
    <link rel="stylesheet" type="text/css" href="extra.css" />
</head>

  <body>

    

    <nav class="navbar navbar-default">
  
  <div class="container">

    <div class="navbar-header">
      
      <div class="navlinks">
          <span class="navbar-brand">
            <a href="https://github.com/tristanlatr/nltk" class="projecthome">Natural Language Toolkit</a> <a href="index.html">API Documentation</a>
          </span>

          <a href="moduleIndex.html">
            Modules
          </a>

          <a href="classIndex.html">
            Classes
          </a>

          <a href="nameIndex.html">
            Names
          </a>
      </div>

    </div>
  </div>
</nav>

    

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><code><a href="nltk.html">nltk</a></code><wbr></wbr>.<code><a href="nltk.tag.html">tag</a></code><wbr></wbr>.<code><a href="nltk.tag.brill_trainer.html">brill_trainer</a></code><wbr></wbr>.<code><a href="nltk.tag.brill_trainer.BrillTaggerTrainer.html">BrillTaggerTrainer</a></code></code></h1>
        <div id="showPrivate">
          <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
        </div>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> <span class="py-defname">BrillTaggerTrainer</span>(<a href="https://docs.python.org/3/library/functions.html#object" title="object">object</a>): <a href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L22" class="sourceLink">(source)</a></code></p>
        <p><a href="classIndex.html#nltk.tag.brill_trainer.BrillTaggerTrainer">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div>A trainer for tbl taggers.</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id1554">
  
  
  <tr class="method">
    
    <td>Method</td>
    <td><code><a href="#__init__">__init__</a></code></td>
    <td><span>Construct a Brill tagger from a baseline tagger and a set of templates</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><code><a href="#train">train</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_apply_rule">_apply_rule</a></code></td>
    <td><span>Update <em>test_sents</em> by applying <em>rule</em> everywhere where its conditions are met.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_best_rule">_best_rule</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_clean">_clean</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_find_rules">_find_rules</a></code></td>
    <td><span>Use the templates to find rules that apply at index <em>wordnum</em> in the sentence <em>sent</em> and generate the tag <em>new_tag</em>.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_init_mappings">_init_mappings</a></code></td>
    <td><span>Initialize the tag position mapping &amp; the rule related mappings.  For each error in test_sents, find new rules that would correct them, and add them to the rule mappings.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_trace_apply">_trace_apply</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_trace_header">_trace_header</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_trace_rule">_trace_rule</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_trace_update_rules">_trace_update_rules</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_update_rule_applies">_update_rule_applies</a></code></td>
    <td><span>Update the rule data tables to reflect the fact that <em>rule</em> applies at the position <em>(sentnum, wordnum)</em>.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_update_rule_not_applies">_update_rule_not_applies</a></code></td>
    <td><span>Update the rule data tables to reflect the fact that <em>rule</em> does not apply at the position <em>(sentnum, wordnum)</em>.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_update_rules">_update_rules</a></code></td>
    <td><span>Check if we should add or remove any rules from consideration, given the changes made by <em>rule</em>.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><code><a href="#_update_tag_positions">_update_tag_positions</a></code></td>
    <td><span>Update _tag_positions to reflect the changes to tags that are made by <em>rule</em>.</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_deterministic">_deterministic</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_first_unknown_position">_first_unknown_position</a></code></td>
    <td><span>Mapping from rules to the first position where we're unsure if the rule applies.  This records the next position we need to check to see if the rule messed anything up.</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_initial_tagger">_initial_tagger</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_positions_by_rule">_positions_by_rule</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_rule_scores">_rule_scores</a></code></td>
    <td><span>Mapping from rules to upper bounds on their effects on the overall score.  This is the inverse mapping to _rules_by_score. Invariant: ruleScores[r] = sum(_positions_by_rule[r])</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_ruleformat">_ruleformat</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_rules_by_position">_rules_by_position</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_rules_by_score">_rules_by_score</a></code></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_tag_positions">_tag_positions</a></code></td>
    <td><span>Mapping from tags to lists of positions that use that tag.</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_templates">_templates</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><code><a href="#_trace">_trace</a></code></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">__init__</span>(self, initial_tagger, templates, trace=0, deterministic=None, ruleformat='str'):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L27">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Construct a Brill tagger from a baseline tagger and a
set of templates<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">initial_tagger:</span>Tagger</td><td class="fieldArgDesc">the baseline tagger</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">templates:</span>list of Templates</td><td class="fieldArgDesc">templates to be used in training</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">trace:</span>int</td><td class="fieldArgDesc">verbosity level</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">deterministic:</span>bool</td><td class="fieldArgDesc">if True, adjudicate ties deterministically</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">ruleformat:</span>str</td><td class="fieldArgDesc">format of reported Rules</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">BrillTagger</td><td class="fieldArgDesc">An untrained BrillTagger</td></tr></table></div>
  </div>
</div><div class="basemethod">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer.train">
    
  </a>
  <a name="train">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">train</span>(self, train_sents, max_rules=200, min_score=2, min_acc=None):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L94">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p>Trains the Brill tagger on the corpus <em>train_sents</em>,
producing at most <em>max_rules</em> transformations, each of which
reduces the net number of errors in the corpus by at least
<em>min_score</em>, and each of which has accuracy not lower than
<em>min_acc</em>.</p>
<p>#imports
&gt;&gt;&gt; from nltk.tbl.template import Template
&gt;&gt;&gt; from nltk.tag.brill import Pos, Word
&gt;&gt;&gt; from nltk.tag import untag, RegexpTagger, BrillTaggerTrainer</p>
<p>#some data
&gt;&gt;&gt; from nltk.corpus import treebank
&gt;&gt;&gt; training_data = treebank.tagged_sents()[:100]
&gt;&gt;&gt; baseline_data = treebank.tagged_sents()[100:200]
&gt;&gt;&gt; gold_data = treebank.tagged_sents()[200:300]
&gt;&gt;&gt; testing_data = [untag(s) for s in gold_data]</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>backoff = RegexpTagger([
<span class="py-more">... </span>(r<span class="py-string">'^-?[0-9]+(.[0-9]+)?$'</span>, <span class="py-string">'CD'</span>),   <span class="py-comment"># cardinal numbers</span>
<span class="py-more">... </span>(r<span class="py-string">'(The|the|A|a|An|an)$'</span>, <span class="py-string">'AT'</span>),   <span class="py-comment"># articles</span>
<span class="py-more">... </span>(r<span class="py-string">'.*able$'</span>, <span class="py-string">'JJ'</span>),                <span class="py-comment"># adjectives</span>
<span class="py-more">... </span>(r<span class="py-string">'.*ness$'</span>, <span class="py-string">'NN'</span>),                <span class="py-comment"># nouns formed from adjectives</span>
<span class="py-more">... </span>(r<span class="py-string">'.*ly$'</span>, <span class="py-string">'RB'</span>),                  <span class="py-comment"># adverbs</span>
<span class="py-more">... </span>(r<span class="py-string">'.*s$'</span>, <span class="py-string">'NNS'</span>),                  <span class="py-comment"># plural nouns</span>
<span class="py-more">... </span>(r<span class="py-string">'.*ing$'</span>, <span class="py-string">'VBG'</span>),                <span class="py-comment"># gerunds</span>
<span class="py-more">... </span>(r<span class="py-string">'.*ed$'</span>, <span class="py-string">'VBD'</span>),                 <span class="py-comment"># past tense verbs</span>
<span class="py-more">... </span>(r<span class="py-string">'.*'</span>, <span class="py-string">'NN'</span>)                      <span class="py-comment"># nouns (default)</span>
<span class="py-more">... </span>])</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>baseline = backoff <span class="py-comment">#see NOTE1</span></pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>baseline.evaluate(gold_data) <span class="py-comment">#doctest: +ELLIPSIS</span>
<span class="py-output">0.2450142...</span>
</pre><p>#templates
&gt;&gt;&gt; Template._cleartemplates() #clear any templates created in earlier tests
&gt;&gt;&gt; templates = [Template(Pos([-1])), Template(Pos([-1]), Word([0]))]</p>
<p>#construct a BrillTaggerTrainer
&gt;&gt;&gt; tt = BrillTaggerTrainer(baseline, templates, trace=3)</p>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>tagger1 = tt.train(training_data, max_rules=10)
<span class="py-output">TBL train (fast) (seqs: 100; tokens: 2417; tpls: 2; min score: 2; min acc: None)</span>
<span class="py-output">Finding initial useful rules...</span>
<span class="py-output">    Found 845 useful rules.</span>
<span class="py-output">&lt;BLANKLINE&gt;</span>
<span class="py-output">           B      |</span>
<span class="py-output">   S   F   r   O  |        Score = Fixed - Broken</span>
<span class="py-output">   c   i   o   t  |  R     Fixed = num tags changed incorrect -&gt; correct</span>
<span class="py-output">   o   x   k   h  |  u     Broken = num tags changed correct -&gt; incorrect</span>
<span class="py-output">   r   e   e   e  |  l     Other = num tags changed incorrect -&gt; incorrect</span>
<span class="py-output">   e   d   n   r  |  e</span>
<span class="py-output">------------------+-------------------------------------------------------</span>
<span class="py-output"> 132 132   0   0  | AT-&gt;DT if Pos:NN@[-1]</span>
<span class="py-output">  85  85   0   0  | NN-&gt;, if Pos:NN@[-1] &amp; Word:,@[0]</span>
<span class="py-output">  69  69   0   0  | NN-&gt;. if Pos:NN@[-1] &amp; Word:.@[0]</span>
<span class="py-output">  51  51   0   0  | NN-&gt;IN if Pos:NN@[-1] &amp; Word:of@[0]</span>
<span class="py-output">  47  63  16 161  | NN-&gt;IN if Pos:NNS@[-1]</span>
<span class="py-output">  33  33   0   0  | NN-&gt;TO if Pos:NN@[-1] &amp; Word:to@[0]</span>
<span class="py-output">  26  26   0   0  | IN-&gt;. if Pos:NNS@[-1] &amp; Word:.@[0]</span>
<span class="py-output">  24  24   0   0  | IN-&gt;, if Pos:NNS@[-1] &amp; Word:,@[0]</span>
<span class="py-output">  22  27   5  24  | NN-&gt;-NONE- if Pos:VBD@[-1]</span>
<span class="py-output">  17  17   0   0  | NN-&gt;CC if Pos:NN@[-1] &amp; Word:and@[0]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>tagger1.rules()[1:3]
<span class="py-output">(Rule('001', 'NN', ',', [(Pos([-1]),'NN'), (Word([0]),',')]), Rule('001', 'NN', '.', [(Pos([-1]),'NN'), (Word([0]),'.')]))</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>train_stats = tagger1.train_stats()
<span class="py-prompt">&gt;&gt;&gt; </span>[train_stats[stat] <span class="py-keyword">for</span> stat <span class="py-keyword">in</span> [<span class="py-string">'initialerrors'</span>, <span class="py-string">'finalerrors'</span>, <span class="py-string">'rulescores'</span>]]
<span class="py-output">[1775, 1269, [132, 85, 69, 51, 47, 33, 26, 24, 22, 17]]</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>tagger1.print_template_statistics(printunused=<span class="py-builtin">False</span>)
<span class="py-output">TEMPLATE STATISTICS (TRAIN)  2 templates, 10 rules)</span>
<span class="py-output">TRAIN (   2417 tokens) initial  1775 0.2656 final:  1269 0.4750</span>
<span class="py-output">#ID | Score (train) |  #Rules     | Template</span>
<span class="py-output">--------------------------------------------</span>
<span class="py-output">001 |   305   0.603 |   7   0.700 | Template(Pos([-1]),Word([0]))</span>
<span class="py-output">000 |   201   0.397 |   3   0.300 | Template(Pos([-1]))</span>
<span class="py-output">&lt;BLANKLINE&gt;</span>
<span class="py-output">&lt;BLANKLINE&gt;</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>tagger1.evaluate(gold_data) <span class="py-comment"># doctest: +ELLIPSIS</span>
<span class="py-output">0.43996...</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>tagged, test_stats = tagger1.batch_tag_incremental(testing_data, gold_data)</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>tagged[33][12:] == [(<span class="py-string">'foreign'</span>, <span class="py-string">'IN'</span>), (<span class="py-string">'debt'</span>, <span class="py-string">'NN'</span>), (<span class="py-string">'of'</span>, <span class="py-string">'IN'</span>), (<span class="py-string">'$'</span>, <span class="py-string">'NN'</span>), (<span class="py-string">'64'</span>, <span class="py-string">'CD'</span>),
<span class="py-more">... </span>(<span class="py-string">'billion'</span>, <span class="py-string">'NN'</span>), (<span class="py-string">'*U*'</span>, <span class="py-string">'NN'</span>), (<span class="py-string">'--'</span>, <span class="py-string">'NN'</span>), (<span class="py-string">'the'</span>, <span class="py-string">'DT'</span>), (<span class="py-string">'third-highest'</span>, <span class="py-string">'NN'</span>), (<span class="py-string">'in'</span>, <span class="py-string">'NN'</span>),
<span class="py-more">... </span>(<span class="py-string">'the'</span>, <span class="py-string">'DT'</span>), (<span class="py-string">'developing'</span>, <span class="py-string">'VBG'</span>), (<span class="py-string">'world'</span>, <span class="py-string">'NN'</span>), (<span class="py-string">'.'</span>, <span class="py-string">'.'</span>)]
<span class="py-output">True</span>
</pre><pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>[test_stats[stat] <span class="py-keyword">for</span> stat <span class="py-keyword">in</span> [<span class="py-string">'initialerrors'</span>, <span class="py-string">'finalerrors'</span>, <span class="py-string">'rulescores'</span>]]
<span class="py-output">[1855, 1376, [100, 85, 67, 58, 27, 36, 27, 16, 31, 32]]</span>
</pre><p># a high-accuracy tagger
&gt;&gt;&gt; tagger2 = tt.train(training_data, max_rules=10, min_acc=0.99)
TBL train (fast) (seqs: 100; tokens: 2417; tpls: 2; min score: 2; min acc: 0.99)
Finding initial useful rules...</p>
<blockquote>
Found 845 useful rules.</blockquote>
<dl class="rst-docutils">
<dt>&lt;BLANKLINE&gt;</dt>
<dd><blockquote class="rst-first">
B      |</blockquote>
<p class="rst-last">S   F   r   O  |        Score = Fixed - Broken
c   i   o   t  |  R     Fixed = num tags changed incorrect -&gt; correct
o   x   k   h  |  u     Broken = num tags changed correct -&gt; incorrect
r   e   e   e  |  l     Other = num tags changed incorrect -&gt; incorrect
e   d   n   r  |  e</p>
</dd>
<dt>------------------+-------------------------------------------------------</dt>
<dd><dl class="rst-first rst-last rst-docutils">
<dt>132 132   0   0  | AT-&gt;DT if Pos:NN@[-1]</dt>
<dd>85  85   0   0  | NN-&gt;, if Pos:NN@[-1] &amp; Word:,@[0]
69  69   0   0  | NN-&gt;. if Pos:NN@[-1] &amp; Word:.@[0]
51  51   0   0  | NN-&gt;IN if Pos:NN@[-1] &amp; Word:of@[0]
36  36   0   0  | NN-&gt;TO if Pos:NN@[-1] &amp; Word:to@[0]
26  26   0   0  | NN-&gt;. if Pos:NNS@[-1] &amp; Word:.@[0]
24  24   0   0  | NN-&gt;, if Pos:NNS@[-1] &amp; Word:,@[0]
19  19   0   6  | NN-&gt;VB if Pos:TO@[-1]
18  18   0   0  | CD-&gt;-NONE- if Pos:NN@[-1] &amp; Word:0@[0]
18  18   0   0  | NN-&gt;CC if Pos:NN@[-1] &amp; Word:and@[0]</dd>
</dl>
</dd>
</dl>
<pre class="py-doctest">
<span class="py-prompt">&gt;&gt;&gt; </span>tagger2.evaluate(gold_data)  <span class="py-comment"># doctest: +ELLIPSIS</span>
<span class="py-output">0.44159544...</span>
<span class="py-prompt">&gt;&gt;&gt; </span>tagger2.rules()[2:4]
<span class="py-output">(Rule('001', 'NN', '.', [(Pos([-1]),'NN'), (Word([0]),'.')]), Rule('001', 'NN', 'IN', [(Pos([-1]),'NN'), (Word([0]),'of')]))</span>
</pre><p># NOTE1: (!!FIXME) A far better baseline uses nltk.tag.UnigramTagger,
# with a RegexpTagger only as backoff. For instance,
# &gt;&gt;&gt; baseline = UnigramTagger(baseline_data, backoff=backoff)
# However, as of Nov 2013, nltk.tag.UnigramTagger does not yield consistent results
# between python versions. The simplistic backoff above is a workaround to make doctests
# get consistent input.</p>
<table class="fieldTable"><tr class="fieldStart"><td class="fieldName" colspan="2">Parameters</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">train_sents:</span>list(list(tuple))</td><td class="fieldArgDesc">training data</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">max_rules:</span>int</td><td class="fieldArgDesc">output at most max_rules rules</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">min_score:</span>int</td><td class="fieldArgDesc">stop training when no rules better than min_score can be found</td></tr><tr><td class="fieldArgContainer"><span class="fieldArg">min_acc:</span>float or None</td><td class="fieldArgDesc">discard any rule with lower accuracy than min_acc</td></tr><tr class="fieldStart"><td class="fieldName" colspan="2">Returns</td></tr><tr><td class="fieldArgContainer">BrillTagger</td><td class="fieldArgDesc">the learned tagger</td></tr></table></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._apply_rule">
    
  </a>
  <a name="_apply_rule">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_apply_rule</span>(self, rule, test_sents):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L486">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Update <em>test_sents</em> by applying <em>rule</em> everywhere where its
conditions are met.</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._best_rule">
    
  </a>
  <a name="_best_rule">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_best_rule</span>(self, train_sents, test_sents, min_score, min_acc):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L431">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Find the next best rule.  This is done by repeatedly taking a
rule with the highest score and stepping through the corpus to
see where it applies.  When it makes an error (decreasing its
score) it's bumped down, and we try a new rule with the
highest score.  When we find a rule which has the highest
score <em>and</em> which has been tested against the entire corpus, we
can conclude that it's the next best rule.</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._clean">
    
  </a>
  <a name="_clean">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_clean</span>(self):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L360">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._find_rules">
    
  </a>
  <a name="_find_rules">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_find_rules</span>(self, sent, wordnum, new_tag):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L368">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Use the templates to find rules that apply at index <em>wordnum</em>
in the sentence <em>sent</em> and generate the tag <em>new_tag</em>.</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._init_mappings">
    
  </a>
  <a name="_init_mappings">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_init_mappings</span>(self, test_sents, train_sents):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L334">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Initialize the tag position mapping &amp; the rule related
mappings.  For each error in test_sents, find new rules that
would correct them, and add them to the rule mappings.</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._trace_apply">
    
  </a>
  <a name="_trace_apply">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_trace_apply</span>(self, num_updates):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L616">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._trace_header">
    
  </a>
  <a name="_trace_header">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_trace_header</span>(self):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L578">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._trace_rule">
    
  </a>
  <a name="_trace_rule">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_trace_rule</span>(self, rule):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L591">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._trace_update_rules">
    
  </a>
  <a name="_trace_update_rules">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_trace_update_rules</span>(self, num_obsolete, num_new, num_unseen):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L621">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._update_rule_applies">
    
  </a>
  <a name="_update_rule_applies">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_update_rule_applies</span>(self, rule, sentnum, wordnum, train_sents):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L377">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Update the rule data tables to reflect the fact that
<em>rule</em> applies at the position <em>(sentnum, wordnum)</em>.</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._update_rule_not_applies">
    
  </a>
  <a name="_update_rule_not_applies">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_update_rule_not_applies</span>(self, rule, sentnum, wordnum):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L409">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Update the rule data tables to reflect the fact that <em>rule</em>
does not apply at the position <em>(sentnum, wordnum)</em>.</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._update_rules">
    
  </a>
  <a name="_update_rules">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_update_rules</span>(self, rule, train_sents, test_sents):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L517">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Check if we should add or remove any rules from consideration,
given the changes made by <em>rule</em>.</div>
  </div>
</div><div class="basemethod private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._update_tag_positions">
    
  </a>
  <a name="_update_tag_positions">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-keyword">def</span> <span class="py-defname">_update_tag_positions</span>(self, rule):
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L502">
      
      (source)
    </a>
  </div>
  <div class="docstring functionBody">
    
    
    <div>Update _tag_positions to reflect the changes to tags that are
made by <em>rule</em>.</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._deterministic">
    
  </a>
  <a name="_deterministic">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_deterministic</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L53">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._first_unknown_position">
    
  </a>
  <a name="_first_unknown_position">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_first_unknown_position</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L87">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>Mapping from rules to the first position where we're unsure
if the rule applies.  This records the next position we
need to check to see if the rule messed anything up.</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._initial_tagger">
    
  </a>
  <a name="_initial_tagger">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_initial_tagger</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L50">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._positions_by_rule">
    
  </a>
  <a name="_positions_by_rule">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_positions_by_rule</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L67">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>Mapping from rule to position to effect, specifying the
effect that each rule has on the overall score, at each
position.  Position is (sentnum, wordnum); and effect is
-1, 0, or 1.  As with _rules_by_position, this mapping starts
out only containing rules with positive effects; but when
we examine a rule, we'll extend this mapping to include
the positions where the rule is harmful or neutral.</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._rule_scores">
    
  </a>
  <a name="_rule_scores">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_rule_scores</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L82">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>Mapping from rules to upper bounds on their effects on the
overall score.  This is the inverse mapping to _rules_by_score.
Invariant: ruleScores[r] = sum(_positions_by_rule[r])</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._ruleformat">
    
  </a>
  <a name="_ruleformat">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_ruleformat</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L54">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._rules_by_position">
    
  </a>
  <a name="_rules_by_position">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_rules_by_position</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L59">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>Mapping from positions to the set of rules that are known
to occur at that position.  Position is (sentnum, wordnum).
Initially, this will only contain positions where each rule
applies in a helpful way; but when we examine a rule, we'll
extend this list to also include positions where each rule
applies in a harmful or neutral way.</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._rules_by_score">
    
  </a>
  <a name="_rules_by_score">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_rules_by_score</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L76">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>Mapping from scores to the set of rules whose effect on the
overall score is upper bounded by that score.  Invariant:
rulesByScore[s] will contain r iff the sum of
_positions_by_rule[r] is s.</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._tag_positions">
    
  </a>
  <a name="_tag_positions">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_tag_positions</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L56">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div>Mapping from tags to lists of positions that use that tag.</div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._templates">
    
  </a>
  <a name="_templates">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_templates</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L51">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  
  <a name="nltk.tag.brill_trainer.BrillTaggerTrainer._trace">
    
  </a>
  <a name="_trace">
    
  </a>
  <div class="functionHeader">
    
    <span class="py-defname">_trace</span> =
    <a class="sourceLink" href="https://github.com/tristanlatr/nltk/tree/03a34b1932460e632ce9048adc0ccabbc7c0558c/nltk/tag/brill_trainer.py#L52">
      
      (source)
    </a>
  </div>
  <div class="functionBody">
    
    
    <div><p class="undocumented">Undocumented</p></div>
  </div>
</div>

      </div>
    </div>

    <footer class="navbar navbar-default">
  
  <div class="container">
    <a href="index.html">API Documentation</a> for <a href="https://github.com/tristanlatr/nltk" class="projecthome">Natural Language Toolkit</a>,
  generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a>
    21.2.2 at 2021-06-22 02:56:13.
  </div>
</footer>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>